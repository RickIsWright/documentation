{"content":"\n<p>Unity is designed to support a range of common scenarios for resolving instances of objects that, themselves, depend on other objects or services. However, you must first prepare your application to use Unity. The following procedure describes how to include the necessary assemblies and elements in your code.</p>\n<h2 id=\"to-prepare-your-application\">To prepare your application</h2>\n<p>Before you can add Unity to your solution you need to decide if you want to reference packages individually (<a href=\"https://www.nuget.org/packages/Unity.Abstractions/\" data-linktype=\"external\">Abstractions</a>, <a href=\"https://www.nuget.org/packages/Unity.Container/\" data-linktype=\"external\">Container</a>) or use composite <a href=\"https://www.nuget.org/packages/Unity\" data-linktype=\"external\">Unity</a> package.</p>\n<h3 id=\"referencing-composite-package\">Referencing composite package</h3>\n<p>Referencing single <a href=\"https://www.nuget.org/packages/Unity/\" data-linktype=\"external\">Unity</a> package is more appropriate in case of small(ish) project, when everything is contained within one solution. Upgrading such solution is trivial with the help of NuGet Manager.</p>\n<h3 id=\"referencing-individual-packages\">Referencing individual packages</h3>\n<p>Main benefit of referencing <a href=\"https://www.nuget.org/packages/Unity.Abstractions/\" data-linktype=\"external\">Abstractions</a> and <a href=\"https://www.nuget.org/packages/Unity.Container/\" data-linktype=\"external\">Container</a> packages individually is when it is used in large project spanning multiple solutions, modules, and project files.</p>\n<p>Normally modular systems have one main application/module with boot-loader responsible for initializing environment, and number of modules loaded by it (<a href=\"https://prismlibrary.github.io/\" data-linktype=\"external\">Prism library</a> for example). This boot loader is required to reference both <a href=\"https://www.nuget.org/packages/Unity.Abstractions/\" data-linktype=\"external\">Abstractions</a> and <a href=\"https://www.nuget.org/packages/Unity.Container/\" data-linktype=\"external\">Container</a> packages.</p>\n<p>In such systems modules are created and distributed by various teams and departments and synchronization between these might be a challenge. This is where Unity comes in.\nAs stated elsewhere on this site <a href=\"https://www.nuget.org/packages/Unity.Abstractions/\" data-linktype=\"external\">Unity.Abstractions</a> contains all declarations required by Unity to operate. Because of that modules could only reference one assembly: <a href=\"https://www.nuget.org/packages/Unity.Abstractions/\" data-linktype=\"external\">Unity.Abstractions</a></p>\n<p>This separation allows updates of patched container's engine without recompiling all the modules used in the system. Given that specifications change very infrequently and <a href=\"https://www.nuget.org/packages/Unity.Abstractions/\" data-linktype=\"external\">Unity.Abstractions</a> package stays the same most of the time it provides big benefit in terms of saved development/testing time and money.</p>\n<h2 id=\"adding-unity-to-project\">Adding Unity to project</h2>\n<p>Unity container is distributed via NuGet and could be added to a project with the help of NuGet manager or by executing command:</p>\n<pre><code class=\"lang-bash\">Install-Package Unity\n\nor\n\nInstall-Package Unity.Abstractions\nInstall-Package Unity.Container\n</code></pre>\n<p>If you wish to use <a href=\"https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#floating-versions\" data-linktype=\"external\">Floating Version references</a> it is recommended to lock in the minor and major versions and only allow patch version to slide:</p>\n<pre><code class=\"lang-js\">&lt;PackageReference Include=&quot;Unity.Container&quot; Version=&quot;5.9.*&quot; /&gt;\n</code></pre>\n<p>doing so will guarantee that no breaking change caught you of guard.</p>\n","page":{"_appFaviconPath":"images/favicon.png","_appFooter":"<span>Copyright &copy; 2008â€“2019 <strong>Unity Container</strong> project</span>","_appLogoPath":"images/logo.svg","_appTitle":"Unity Container","_op_canonicalUrlPrefix":"https://en-us/","_op_gitContributorInformation":{"update_at":"3/4/2019","updated_at_date_time":"2019-03-04T02:14:05Z"},"_path":"articles/installation/index.html","_tocRel":"../toc.json","canonical_url":"https:///en-us/articles/installation/","conceptual":"\n<p>Unity is designed to support a range of common scenarios for resolving instances of objects that, themselves, depend on other objects or services. However, you must first prepare your application to use Unity. The following procedure describes how to include the necessary assemblies and elements in your code.</p>\n<h2 id=\"to-prepare-your-application\">To prepare your application</h2>\n<p>Before you can add Unity to your solution you need to decide if you want to reference packages individually (<a href=\"https://www.nuget.org/packages/Unity.Abstractions/\" data-linktype=\"external\">Abstractions</a>, <a href=\"https://www.nuget.org/packages/Unity.Container/\" data-linktype=\"external\">Container</a>) or use composite <a href=\"https://www.nuget.org/packages/Unity\" data-linktype=\"external\">Unity</a> package.</p>\n<h3 id=\"referencing-composite-package\">Referencing composite package</h3>\n<p>Referencing single <a href=\"https://www.nuget.org/packages/Unity/\" data-linktype=\"external\">Unity</a> package is more appropriate in case of small(ish) project, when everything is contained within one solution. Upgrading such solution is trivial with the help of NuGet Manager.</p>\n<h3 id=\"referencing-individual-packages\">Referencing individual packages</h3>\n<p>Main benefit of referencing <a href=\"https://www.nuget.org/packages/Unity.Abstractions/\" data-linktype=\"external\">Abstractions</a> and <a href=\"https://www.nuget.org/packages/Unity.Container/\" data-linktype=\"external\">Container</a> packages individually is when it is used in large project spanning multiple solutions, modules, and project files.</p>\n<p>Normally modular systems have one main application/module with boot-loader responsible for initializing environment, and number of modules loaded by it (<a href=\"https://prismlibrary.github.io/\" data-linktype=\"external\">Prism library</a> for example). This boot loader is required to reference both <a href=\"https://www.nuget.org/packages/Unity.Abstractions/\" data-linktype=\"external\">Abstractions</a> and <a href=\"https://www.nuget.org/packages/Unity.Container/\" data-linktype=\"external\">Container</a> packages.</p>\n<p>In such systems modules are created and distributed by various teams and departments and synchronization between these might be a challenge. This is where Unity comes in.\nAs stated elsewhere on this site <a href=\"https://www.nuget.org/packages/Unity.Abstractions/\" data-linktype=\"external\">Unity.Abstractions</a> contains all declarations required by Unity to operate. Because of that modules could only reference one assembly: <a href=\"https://www.nuget.org/packages/Unity.Abstractions/\" data-linktype=\"external\">Unity.Abstractions</a></p>\n<p>This separation allows updates of patched container's engine without recompiling all the modules used in the system. Given that specifications change very infrequently and <a href=\"https://www.nuget.org/packages/Unity.Abstractions/\" data-linktype=\"external\">Unity.Abstractions</a> package stays the same most of the time it provides big benefit in terms of saved development/testing time and money.</p>\n<h2 id=\"adding-unity-to-project\">Adding Unity to project</h2>\n<p>Unity container is distributed via NuGet and could be added to a project with the help of NuGet manager or by executing command:</p>\n<pre><code class=\"lang-bash\">Install-Package Unity\n\nor\n\nInstall-Package Unity.Abstractions\nInstall-Package Unity.Container\n</code></pre>\n<p>If you wish to use <a href=\"https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#floating-versions\" data-linktype=\"external\">Floating Version references</a> it is recommended to lock in the minor and major versions and only allow patch version to slide:</p>\n<pre><code class=\"lang-js\">&lt;PackageReference Include=&quot;Unity.Container&quot; Version=&quot;5.9.*&quot; /&gt;\n</code></pre>\n<p>doing so will guarantee that no breaking change caught you of guard.</p>\n","content_git_url":"https://github.com/unitycontainer/documentation/blob/develop/articles/installation.md","depot_name":".","document_id":"f2c12317-d328-78fd-cc78-8bf80690406d","document_version_independent_id":"623501b4-0f80-ff38-3a41-051d28f127a9","gitcommit":"https://github.com/unitycontainer/documentation/blob/a08c5cd38778dbc7606660e730b63c1a6800daf1/articles/installation.md","locale":"en-us","original_content_git_url":"https://github.com/unitycontainer/documentation/blob/develop/articles/installation.md","original_content_git_url_template":"{repo}/blob/{branch}/articles/installation.md","rawTitle":"<h1 id=\"adding-unity-to-your-application\">Adding Unity to Your Application</h1>","search.ms_docsetname":"","search.ms_product":"","search.ms_sitename":"Docs","site_name":"Docs","title":"Adding Unity to Your Application","uid":"Article.Unity.Install","updated_at":"2019-03-04 02:14 AM","wordCount":347},"metadata":"<meta name=\"canonical_url\" content=\"https:///en-us/articles/installation/\" />\r\n<meta name=\"conceptual\" content=\"\n&lt;p&gt;Unity is designed to support a range of common scenarios for resolving instances of objects that, themselves, depend on other objects or services. However, you must first prepare your application to use Unity. The following procedure describes how to include the necessary assemblies and elements in your code.&lt;/p&gt;\n&lt;h2 id=&quot;to-prepare-your-application&quot;&gt;To prepare your application&lt;/h2&gt;\n&lt;p&gt;Before you can add Unity to your solution you need to decide if you want to reference packages individually (&lt;a href=&quot;https://www.nuget.org/packages/Unity.Abstractions/&quot; data-linktype=&quot;external&quot;&gt;Abstractions&lt;/a&gt;, &lt;a href=&quot;https://www.nuget.org/packages/Unity.Container/&quot; data-linktype=&quot;external&quot;&gt;Container&lt;/a&gt;) or use composite &lt;a href=&quot;https://www.nuget.org/packages/Unity&quot; data-linktype=&quot;external&quot;&gt;Unity&lt;/a&gt; package.&lt;/p&gt;\n&lt;h3 id=&quot;referencing-composite-package&quot;&gt;Referencing composite package&lt;/h3&gt;\n&lt;p&gt;Referencing single &lt;a href=&quot;https://www.nuget.org/packages/Unity/&quot; data-linktype=&quot;external&quot;&gt;Unity&lt;/a&gt; package is more appropriate in case of small(ish) project, when everything is contained within one solution. Upgrading such solution is trivial with the help of NuGet Manager.&lt;/p&gt;\n&lt;h3 id=&quot;referencing-individual-packages&quot;&gt;Referencing individual packages&lt;/h3&gt;\n&lt;p&gt;Main benefit of referencing &lt;a href=&quot;https://www.nuget.org/packages/Unity.Abstractions/&quot; data-linktype=&quot;external&quot;&gt;Abstractions&lt;/a&gt; and &lt;a href=&quot;https://www.nuget.org/packages/Unity.Container/&quot; data-linktype=&quot;external&quot;&gt;Container&lt;/a&gt; packages individually is when it is used in large project spanning multiple solutions, modules, and project files.&lt;/p&gt;\n&lt;p&gt;Normally modular systems have one main application/module with boot-loader responsible for initializing environment, and number of modules loaded by it (&lt;a href=&quot;https://prismlibrary.github.io/&quot; data-linktype=&quot;external&quot;&gt;Prism library&lt;/a&gt; for example). This boot loader is required to reference both &lt;a href=&quot;https://www.nuget.org/packages/Unity.Abstractions/&quot; data-linktype=&quot;external&quot;&gt;Abstractions&lt;/a&gt; and &lt;a href=&quot;https://www.nuget.org/packages/Unity.Container/&quot; data-linktype=&quot;external&quot;&gt;Container&lt;/a&gt; packages.&lt;/p&gt;\n&lt;p&gt;In such systems modules are created and distributed by various teams and departments and synchronization between these might be a challenge. This is where Unity comes in.\nAs stated elsewhere on this site &lt;a href=&quot;https://www.nuget.org/packages/Unity.Abstractions/&quot; data-linktype=&quot;external&quot;&gt;Unity.Abstractions&lt;/a&gt; contains all declarations required by Unity to operate. Because of that modules could only reference one assembly: &lt;a href=&quot;https://www.nuget.org/packages/Unity.Abstractions/&quot; data-linktype=&quot;external&quot;&gt;Unity.Abstractions&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;This separation allows updates of patched container&#39;s engine without recompiling all the modules used in the system. Given that specifications change very infrequently and &lt;a href=&quot;https://www.nuget.org/packages/Unity.Abstractions/&quot; data-linktype=&quot;external&quot;&gt;Unity.Abstractions&lt;/a&gt; package stays the same most of the time it provides big benefit in terms of saved development/testing time and money.&lt;/p&gt;\n&lt;h2 id=&quot;adding-unity-to-project&quot;&gt;Adding Unity to project&lt;/h2&gt;\n&lt;p&gt;Unity container is distributed via NuGet and could be added to a project with the help of NuGet manager or by executing command:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;Install-Package Unity\n\nor\n\nInstall-Package Unity.Abstractions\nInstall-Package Unity.Container\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you wish to use &lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#floating-versions&quot; data-linktype=&quot;external&quot;&gt;Floating Version references&lt;/a&gt; it is recommended to lock in the minor and major versions and only allow patch version to slide:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&amp;lt;PackageReference Include=&amp;quot;Unity.Container&amp;quot; Version=&amp;quot;5.9.*&amp;quot; /&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;doing so will guarantee that no breaking change caught you of guard.&lt;/p&gt;\n\" />\r\n<meta name=\"content_git_url\" content=\"https://github.com/unitycontainer/documentation/blob/develop/articles/installation.md\" />\r\n<meta name=\"depot_name\" content=\".\" />\r\n<meta name=\"document_id\" content=\"f2c12317-d328-78fd-cc78-8bf80690406d\" />\r\n<meta name=\"document_version_independent_id\" content=\"623501b4-0f80-ff38-3a41-051d28f127a9\" />\r\n<meta name=\"gitcommit\" content=\"https://github.com/unitycontainer/documentation/blob/a08c5cd38778dbc7606660e730b63c1a6800daf1/articles/installation.md\" />\r\n<meta name=\"locale\" content=\"en-us\" />\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/unitycontainer/documentation/blob/develop/articles/installation.md\" />\r\n<meta name=\"original_content_git_url_template\" content=\"{repo}/blob/{branch}/articles/installation.md\" />\r\n<meta name=\"rawTitle\" content=\"&lt;h1 id=&quot;adding-unity-to-your-application&quot;&gt;Adding Unity to Your Application&lt;/h1&gt;\" />\r\n<meta name=\"search.ms_docsetname\" content=\"\" />\r\n<meta name=\"search.ms_product\" content=\"\" />\r\n<meta name=\"search.ms_sitename\" content=\"Docs\" />\r\n<meta name=\"site_name\" content=\"Docs\" />\r\n<meta name=\"title\" content=\"Adding Unity to Your Application\" />\r\n<meta name=\"uid\" content=\"Article.Unity.Install\" />\r\n<meta name=\"updated_at\" content=\"2019-03-04 02:14 AM\" />\r\n<meta name=\"wordCount\" content=\"347\" />\r\n<meta name=\"is_dynamic_rendering\" content=\"true\" />\r\n","theme_rel":"..\\..\\_themes"}