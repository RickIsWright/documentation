{"content":"\n<p>Method invocation is an optional step you can add to the created object's initialization. Any accessible method could be invoked, provided Unity can satisfy all the parameters with appropriate values.</p>\n<h2 id=\"method-invocation\">Method Invocation</h2>\n<p>To enable method invocation during object initialization you could apply <a href=\"xref:Unity.InjectionMethodAttribute\" data-linktype=\"external\">InjectionMethod</a> attribute to the method you want to be executed.</p>\n<pre><code class=\"lang-cs\">public class Service\n{\n    ...\n    private void PreInitialize(...)\n    {\n        ...\n    }\n\n    [InjectionMethod]\n    public void Initialize(...)\n    {\n        ...\n    }\n\n    public void PostInitialize(...)\n    {\n        ...\n    }\n}\n</code></pre>\n<p>In the example above, attribute <a href=\"xref:Unity.InjectionMethodAttribute\" data-linktype=\"external\">InjectionMethod</a> is applied to method <code>Initialize(...)</code> and the method will be executed immediately after the object is created.</p>\n<h2 id=\"multiple-method-invocation\">Multiple Method Invocation</h2>\n<p>Unity does not place any restrictions on how many methods of the class will be invoked during the initialization. You could mark any and all methods with the attribute and Unity will execute them all:</p>\n<pre><code class=\"lang-cs\">public class Service\n{\n    ...\n\n    [InjectionMethod]\n    public void PreInitialize(...)\n    {\n        ...\n    }\n\n    [InjectionMethod]\n    public void Initialize(...)\n    {\n        ...\n    }\n\n    [InjectionMethod]\n    public void PostInitialize(...)\n    {\n        ...\n    }\n}\n</code></pre>\n<h2 id=\"restrictions\">Restrictions</h2>\n<h3 id=\"static-methods-cannot-be-invoked\">Static methods cannot be invoked</h3>\n<p>Unity does not support invocation of static methods. Static methods annotated with <a href=\"xref:Unity.InjectionMethodAttribute\" data-linktype=\"external\">InjectionMethod</a> attribute will be ignored. If <a href=\"../../extensions/diagnostic/\" data-linktype=\"relative-path\">Unity Diagnostic</a> is enabled, the container will throw an exception when it encounters such an annotation.</p>\n<h3 id=\"methods-with-ref-or-out-parameters-cannot-be-invoked\">Methods with <code>ref</code> or <code>out</code> parameters cannot be invoked</h3>\n<p>Methods containing <code>ref</code> or <code>out</code> parameters cannot be invoked during initialization. The container will throw an exception if encountered these.</p>\n<pre><code class=\"lang-cs\">public class Service\n{\n    [InjectionMethod]  // Error\n    public void Method1(ref object refObject)\n    {\n        ...\n    }\n    ...\n\n    [InjectionMethod]  // Error\n    public void Method2(out object outObject)\n    {\n        ...\n    }\n}\n</code></pre>\n<p>In the example above neither <code>Method1(ref object refObject)</code> nor <code>Method2(out object outObject)</code> should be annotated for invocation. Doing so will create an error condition.</p>\n<h3 id=\"invoking-private-and-protected-methods-is-not-allowed\">Invoking <code>private</code> and <code>protected</code> methods is not allowed</h3>\n<p>Although it is technically possible to call <code>private</code> and <code>protected</code> methods of the class, Unity does not support this feature. This restriction is implemented to impose consistency with accessibility principles of <code>C#</code> language.</p>\n<p>Unity will ignore attributes on non-accessible methods.</p>\n<pre><code class=\"lang-cs\">public class Service\n{\n    ...\n\n    [InjectionMethod]  // Error\n    protected void ProtectedMethod(...)\n    {\n        ...\n    }\n}\n</code></pre>\n<p>In the example above method <code>ProtectedMethod(...)</code> will not be called.</p>\n<p>If <a href=\"../../extensions/diagnostic/\" data-linktype=\"relative-path\">Unity Diagnostic</a> is enabled, the container will throw an exception when it encounters this condition.</p>\n<p>For more information see  <a href=\"../../extensions/diagnostic/\" data-linktype=\"relative-path\">Unity Diagnostic</a>.</p>\n","page":{"_appFaviconPath":"images/favicon.png","_appFooter":"<span>Copyright &copy; 2008â€“2019 <strong>Unity Container</strong> project</span>","_appLogoPath":"images/logo.svg","_appTitle":"Unity Container","_op_canonicalUrlPrefix":"https://en-us/","_op_gitContributorInformation":{"update_at":"4/5/2019","updated_at_date_time":"2019-04-05T01:56:47Z"},"_path":"tutorials/annotation/method/index.html","_tocRel":"../../toc.json","canonical_url":"https:///en-us/tutorials/annotation/method/","conceptual":"\n<p>Method invocation is an optional step you can add to the created object's initialization. Any accessible method could be invoked, provided Unity can satisfy all the parameters with appropriate values.</p>\n<h2 id=\"method-invocation\">Method Invocation</h2>\n<p>To enable method invocation during object initialization you could apply <a href=\"xref:Unity.InjectionMethodAttribute\" data-linktype=\"external\">InjectionMethod</a> attribute to the method you want to be executed.</p>\n<pre><code class=\"lang-cs\">public class Service\n{\n    ...\n    private void PreInitialize(...)\n    {\n        ...\n    }\n\n    [InjectionMethod]\n    public void Initialize(...)\n    {\n        ...\n    }\n\n    public void PostInitialize(...)\n    {\n        ...\n    }\n}\n</code></pre>\n<p>In the example above, attribute <a href=\"xref:Unity.InjectionMethodAttribute\" data-linktype=\"external\">InjectionMethod</a> is applied to method <code>Initialize(...)</code> and the method will be executed immediately after the object is created.</p>\n<h2 id=\"multiple-method-invocation\">Multiple Method Invocation</h2>\n<p>Unity does not place any restrictions on how many methods of the class will be invoked during the initialization. You could mark any and all methods with the attribute and Unity will execute them all:</p>\n<pre><code class=\"lang-cs\">public class Service\n{\n    ...\n\n    [InjectionMethod]\n    public void PreInitialize(...)\n    {\n        ...\n    }\n\n    [InjectionMethod]\n    public void Initialize(...)\n    {\n        ...\n    }\n\n    [InjectionMethod]\n    public void PostInitialize(...)\n    {\n        ...\n    }\n}\n</code></pre>\n<h2 id=\"restrictions\">Restrictions</h2>\n<h3 id=\"static-methods-cannot-be-invoked\">Static methods cannot be invoked</h3>\n<p>Unity does not support invocation of static methods. Static methods annotated with <a href=\"xref:Unity.InjectionMethodAttribute\" data-linktype=\"external\">InjectionMethod</a> attribute will be ignored. If <a href=\"../../extensions/diagnostic/\" data-linktype=\"relative-path\">Unity Diagnostic</a> is enabled, the container will throw an exception when it encounters such an annotation.</p>\n<h3 id=\"methods-with-ref-or-out-parameters-cannot-be-invoked\">Methods with <code>ref</code> or <code>out</code> parameters cannot be invoked</h3>\n<p>Methods containing <code>ref</code> or <code>out</code> parameters cannot be invoked during initialization. The container will throw an exception if encountered these.</p>\n<pre><code class=\"lang-cs\">public class Service\n{\n    [InjectionMethod]  // Error\n    public void Method1(ref object refObject)\n    {\n        ...\n    }\n    ...\n\n    [InjectionMethod]  // Error\n    public void Method2(out object outObject)\n    {\n        ...\n    }\n}\n</code></pre>\n<p>In the example above neither <code>Method1(ref object refObject)</code> nor <code>Method2(out object outObject)</code> should be annotated for invocation. Doing so will create an error condition.</p>\n<h3 id=\"invoking-private-and-protected-methods-is-not-allowed\">Invoking <code>private</code> and <code>protected</code> methods is not allowed</h3>\n<p>Although it is technically possible to call <code>private</code> and <code>protected</code> methods of the class, Unity does not support this feature. This restriction is implemented to impose consistency with accessibility principles of <code>C#</code> language.</p>\n<p>Unity will ignore attributes on non-accessible methods.</p>\n<pre><code class=\"lang-cs\">public class Service\n{\n    ...\n\n    [InjectionMethod]  // Error\n    protected void ProtectedMethod(...)\n    {\n        ...\n    }\n}\n</code></pre>\n<p>In the example above method <code>ProtectedMethod(...)</code> will not be called.</p>\n<p>If <a href=\"../../extensions/diagnostic/\" data-linktype=\"relative-path\">Unity Diagnostic</a> is enabled, the container will throw an exception when it encounters this condition.</p>\n<p>For more information see  <a href=\"../../extensions/diagnostic/\" data-linktype=\"relative-path\">Unity Diagnostic</a>.</p>\n","content_git_url":"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Annotation/method.md","depot_name":".","document_id":"5ae531df-dce4-5f36-9c71-e384a74e77dc","document_version_independent_id":"f8c80055-fe8e-50ca-9e17-07b04982b1ac","gitcommit":"https://github.com/unitycontainer/documentation/blob/0db2003d37b8f4c0715b03ac831d1d35afe0cd18/tutorials/Annotation/method.md","locale":"en-us","original_content_git_url":"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Annotation/method.md","original_content_git_url_template":"{repo}/blob/{branch}/tutorials/Annotation/method.md","rawTitle":"<h1 id=\"annotating-types-for-method-invocation\">Annotating types for Method invocation</h1>","search.ms_docsetname":"","search.ms_product":"","search.ms_sitename":"Docs","site_name":"Docs","title":"Annotating types for Method invocation","uid":"Tutorial.Annotation.Method","updated_at":"2019-04-05 01:56 AM","wordCount":368},"metadata":"<meta name=\"canonical_url\" content=\"https:///en-us/tutorials/annotation/method/\" />\r\n<meta name=\"conceptual\" content=\"\n&lt;p&gt;Method invocation is an optional step you can add to the created object&#39;s initialization. Any accessible method could be invoked, provided Unity can satisfy all the parameters with appropriate values.&lt;/p&gt;\n&lt;h2 id=&quot;method-invocation&quot;&gt;Method Invocation&lt;/h2&gt;\n&lt;p&gt;To enable method invocation during object initialization you could apply &lt;a href=&quot;xref:Unity.InjectionMethodAttribute&quot; data-linktype=&quot;external&quot;&gt;InjectionMethod&lt;/a&gt; attribute to the method you want to be executed.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;public class Service\n{\n    ...\n    private void PreInitialize(...)\n    {\n        ...\n    }\n\n    [InjectionMethod]\n    public void Initialize(...)\n    {\n        ...\n    }\n\n    public void PostInitialize(...)\n    {\n        ...\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the example above, attribute &lt;a href=&quot;xref:Unity.InjectionMethodAttribute&quot; data-linktype=&quot;external&quot;&gt;InjectionMethod&lt;/a&gt; is applied to method &lt;code&gt;Initialize(...)&lt;/code&gt; and the method will be executed immediately after the object is created.&lt;/p&gt;\n&lt;h2 id=&quot;multiple-method-invocation&quot;&gt;Multiple Method Invocation&lt;/h2&gt;\n&lt;p&gt;Unity does not place any restrictions on how many methods of the class will be invoked during the initialization. You could mark any and all methods with the attribute and Unity will execute them all:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;public class Service\n{\n    ...\n\n    [InjectionMethod]\n    public void PreInitialize(...)\n    {\n        ...\n    }\n\n    [InjectionMethod]\n    public void Initialize(...)\n    {\n        ...\n    }\n\n    [InjectionMethod]\n    public void PostInitialize(...)\n    {\n        ...\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=&quot;restrictions&quot;&gt;Restrictions&lt;/h2&gt;\n&lt;h3 id=&quot;static-methods-cannot-be-invoked&quot;&gt;Static methods cannot be invoked&lt;/h3&gt;\n&lt;p&gt;Unity does not support invocation of static methods. Static methods annotated with &lt;a href=&quot;xref:Unity.InjectionMethodAttribute&quot; data-linktype=&quot;external&quot;&gt;InjectionMethod&lt;/a&gt; attribute will be ignored. If &lt;a href=&quot;../../extensions/diagnostic/&quot; data-linktype=&quot;relative-path&quot;&gt;Unity Diagnostic&lt;/a&gt; is enabled, the container will throw an exception when it encounters such an annotation.&lt;/p&gt;\n&lt;h3 id=&quot;methods-with-ref-or-out-parameters-cannot-be-invoked&quot;&gt;Methods with &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; parameters cannot be invoked&lt;/h3&gt;\n&lt;p&gt;Methods containing &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; parameters cannot be invoked during initialization. The container will throw an exception if encountered these.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;public class Service\n{\n    [InjectionMethod]  // Error\n    public void Method1(ref object refObject)\n    {\n        ...\n    }\n    ...\n\n    [InjectionMethod]  // Error\n    public void Method2(out object outObject)\n    {\n        ...\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the example above neither &lt;code&gt;Method1(ref object refObject)&lt;/code&gt; nor &lt;code&gt;Method2(out object outObject)&lt;/code&gt; should be annotated for invocation. Doing so will create an error condition.&lt;/p&gt;\n&lt;h3 id=&quot;invoking-private-and-protected-methods-is-not-allowed&quot;&gt;Invoking &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; methods is not allowed&lt;/h3&gt;\n&lt;p&gt;Although it is technically possible to call &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; methods of the class, Unity does not support this feature. This restriction is implemented to impose consistency with accessibility principles of &lt;code&gt;C#&lt;/code&gt; language.&lt;/p&gt;\n&lt;p&gt;Unity will ignore attributes on non-accessible methods.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;public class Service\n{\n    ...\n\n    [InjectionMethod]  // Error\n    protected void ProtectedMethod(...)\n    {\n        ...\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the example above method &lt;code&gt;ProtectedMethod(...)&lt;/code&gt; will not be called.&lt;/p&gt;\n&lt;p&gt;If &lt;a href=&quot;../../extensions/diagnostic/&quot; data-linktype=&quot;relative-path&quot;&gt;Unity Diagnostic&lt;/a&gt; is enabled, the container will throw an exception when it encounters this condition.&lt;/p&gt;\n&lt;p&gt;For more information see  &lt;a href=&quot;../../extensions/diagnostic/&quot; data-linktype=&quot;relative-path&quot;&gt;Unity Diagnostic&lt;/a&gt;.&lt;/p&gt;\n\" />\r\n<meta name=\"content_git_url\" content=\"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Annotation/method.md\" />\r\n<meta name=\"depot_name\" content=\".\" />\r\n<meta name=\"document_id\" content=\"5ae531df-dce4-5f36-9c71-e384a74e77dc\" />\r\n<meta name=\"document_version_independent_id\" content=\"f8c80055-fe8e-50ca-9e17-07b04982b1ac\" />\r\n<meta name=\"gitcommit\" content=\"https://github.com/unitycontainer/documentation/blob/0db2003d37b8f4c0715b03ac831d1d35afe0cd18/tutorials/Annotation/method.md\" />\r\n<meta name=\"locale\" content=\"en-us\" />\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Annotation/method.md\" />\r\n<meta name=\"original_content_git_url_template\" content=\"{repo}/blob/{branch}/tutorials/Annotation/method.md\" />\r\n<meta name=\"rawTitle\" content=\"&lt;h1 id=&quot;annotating-types-for-method-invocation&quot;&gt;Annotating types for Method invocation&lt;/h1&gt;\" />\r\n<meta name=\"search.ms_docsetname\" content=\"\" />\r\n<meta name=\"search.ms_product\" content=\"\" />\r\n<meta name=\"search.ms_sitename\" content=\"Docs\" />\r\n<meta name=\"site_name\" content=\"Docs\" />\r\n<meta name=\"title\" content=\"Annotating types for Method invocation\" />\r\n<meta name=\"uid\" content=\"Tutorial.Annotation.Method\" />\r\n<meta name=\"updated_at\" content=\"2019-04-05 01:56 AM\" />\r\n<meta name=\"wordCount\" content=\"368\" />\r\n<meta name=\"is_dynamic_rendering\" content=\"true\" />\r\n","theme_rel":"..\\..\\..\\_themes"}