{"content":"\n<p>Type registration is where all the Unity magic is happening. It provides complete and flexible control of all aspects of type creation and management.</p>\n<p>When a <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> is registered Unity creates a contract (a registration) consisting of a <strong>Type</strong>, a <strong>Name</strong>, and instructions on how this contract should be fulfilled when requested.</p>\n<h2 id=\"minimum-registration-requirements\">Minimum Registration Requirements</h2>\n<p>The only required part of the registration is a registered <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> itself. Theoretically you could register a <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> like this:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;Service&gt;();\n</code></pre>\n<p>This would tell the container to use all defaults when creating <code>Service</code>. Registrations like this do not make much sense. If creation process does not require any customization, all that time spent on registering such <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> is wasted. It is measurably faster to resolve a plain <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> from the container if it is not registered at all.</p>\n<p>When a <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> is annotated with injection attributes it does not require registration either. If you are satisfied with annotated selections, appropriate constructor and all other members are annotated, and you do not require lifetime management for created instances, the <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> should not be registered.</p>\n<p>You should only register types if at least one of the following is true:</p>\n<ul>\n<li>Contract/Registration requires a Name</li>\n<li>Require a mapping between service and implementation types</li>\n<li>Require lifetime policy other than transient</li>\n<li>Need to override injection annotated with attribute(s)</li>\n<li>Nondefault constructor should be selected</li>\n<li>Properties or fields should be injected</li>\n<li>Method(s) should be called during initialization</li>\n</ul>\n<h2 id=\"creating-registration-contracts\">Creating Registration Contracts</h2>\n<p>Simplest form of a contract is a registration without a Name ( the Name is <code>null</code> ). This type of registration is called <code>default</code> and in some cases is used as a prototype during resolution of Generic types (hence name <code>default</code>).</p>\n<p>A contract could have a Name. The Name could be any arbitrary string of one or more characters. The simple named contract could be registered like this:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;Service&gt;(&quot;Contract Name&quot;);\n</code></pre>\n<div class=\"NOTE\">\n<h5>NOTE</h5>\n<p>It is not recommended to use empty strings as names.</p>\n</div>\n<h2 id=\"creating-type-mapping\">Creating Type Mapping</h2>\n<p>A mapping instructs Unity on how to satisfy the contract and what implementation <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> should be used to create an object. For example is you want to associate an interface <code>IService</code> with implementation <code>Service</code> you would register it like this:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;IService, Service&gt;();\n</code></pre>\n<p>Or you could register multiple implementations for the same service:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;IService, MailService&gt;(&quot;Email&quot;);\ncontainer.RegisterType&lt;IService, WebService&gt;(&quot;WebMail&quot;);\ncontainer.RegisterType&lt;IService, SecureService&gt;(&quot;Encrypted&quot;);\n</code></pre>\n<p>For more information see &lt;xref:Tutorial.Registration.Mapping&gt;</p>\n<h2 id=\"lifetime-management\">Lifetime Management</h2>\n<p>Unity provides wide variety of lifetime managers <a href=\"xref:Unity.TypeLifetime\" data-linktype=\"external\">compatible</a> with type registrations. Each of these managers provide unique algorithm for instance management.</p>\n<p>In example above services are created on each request. In most cases it is desireable to create services only once. To create singleton services appropriate lifetime managers must be added to the registration:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;IService, MailService&gt;(&quot;Email&quot;, TypeLifetime.Singleton);\ncontainer.RegisterType&lt;IService, WebService&gt;(&quot;WebMail&quot;, TypeLifetime.Singleton);\ncontainer.RegisterType&lt;IService, SecureService&gt;(&quot;Encrypted&quot;, TypeLifetime.Singleton);\n</code></pre>\n<p>For more information about lifetime management see <a href=\"../../../lifetime/lifetime/\" data-linktype=\"relative-path\">Lifetime Management</a></p>\n<h2 id=\"creation-pipeline\">Creation Pipeline</h2>\n<p>Unity instantiates an objects by creating a resolver pipeline and executing it with passed in injection values. Each pipeline consists of a several steps with each step performing part of the initialization.</p>\n<p>How the pipeline is assembled and what values are injected is controlled by collection of <a href=\"xref:Unity.Injection.InjectionMember\" data-linktype=\"external\">Injection Member</a> objects passed to registration method. The normal steps of the object creation process are:</p>\n<h2 id=\"injection-instructions\">Injection Instructions</h2>\n<p>During the registration you could Configure the container to select certain constructor, initialize properties and fields, call methods, and inject values and instructions for dependencies. All this is done by passing appropriate <a href=\"xref:Unity.Injection\" data-linktype=\"external\">Injection Members</a> to the registration. For more information see:</p>\n<ul>\n<li><a href=\"../constructor/constructor/\" data-linktype=\"relative-path\">Constructor invocation and injection</a></li>\n<li><a href=\"../field/\" data-linktype=\"relative-path\">Fields injection</a></li>\n<li><a href=\"../property/\" data-linktype=\"relative-path\">Properties injection</a></li>\n<li><a href=\"../method/\" data-linktype=\"relative-path\">Method(s) invocation and injection</a></li>\n</ul>\n","page":{"_appFaviconPath":"images/favicon.png","_appFooter":"<span>Copyright &copy; 2008â€“2019 <strong>Unity Container</strong> project</span>","_appLogoPath":"images/logo.svg","_appTitle":"Unity Container","_op_canonicalUrlPrefix":"https://en-us/","_op_gitContributorInformation":{"update_at":"3/11/2019","updated_at_date_time":"2019-03-11T00:52:36Z"},"_path":"tutorials/registration/type/registration/index.html","_tocRel":"../../../toc.json","canonical_url":"https:///en-us/tutorials/registration/type/registration/","conceptual":"\n<p>Type registration is where all the Unity magic is happening. It provides complete and flexible control of all aspects of type creation and management.</p>\n<p>When a <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> is registered Unity creates a contract (a registration) consisting of a <strong>Type</strong>, a <strong>Name</strong>, and instructions on how this contract should be fulfilled when requested.</p>\n<h2 id=\"minimum-registration-requirements\">Minimum Registration Requirements</h2>\n<p>The only required part of the registration is a registered <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> itself. Theoretically you could register a <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> like this:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;Service&gt;();\n</code></pre>\n<p>This would tell the container to use all defaults when creating <code>Service</code>. Registrations like this do not make much sense. If creation process does not require any customization, all that time spent on registering such <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> is wasted. It is measurably faster to resolve a plain <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> from the container if it is not registered at all.</p>\n<p>When a <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> is annotated with injection attributes it does not require registration either. If you are satisfied with annotated selections, appropriate constructor and all other members are annotated, and you do not require lifetime management for created instances, the <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> should not be registered.</p>\n<p>You should only register types if at least one of the following is true:</p>\n<ul>\n<li>Contract/Registration requires a Name</li>\n<li>Require a mapping between service and implementation types</li>\n<li>Require lifetime policy other than transient</li>\n<li>Need to override injection annotated with attribute(s)</li>\n<li>Nondefault constructor should be selected</li>\n<li>Properties or fields should be injected</li>\n<li>Method(s) should be called during initialization</li>\n</ul>\n<h2 id=\"creating-registration-contracts\">Creating Registration Contracts</h2>\n<p>Simplest form of a contract is a registration without a Name ( the Name is <code>null</code> ). This type of registration is called <code>default</code> and in some cases is used as a prototype during resolution of Generic types (hence name <code>default</code>).</p>\n<p>A contract could have a Name. The Name could be any arbitrary string of one or more characters. The simple named contract could be registered like this:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;Service&gt;(&quot;Contract Name&quot;);\n</code></pre>\n<div class=\"NOTE\">\n<h5>NOTE</h5>\n<p>It is not recommended to use empty strings as names.</p>\n</div>\n<h2 id=\"creating-type-mapping\">Creating Type Mapping</h2>\n<p>A mapping instructs Unity on how to satisfy the contract and what implementation <a href=\"xref:System.Type\" data-linktype=\"external\">Type</a> should be used to create an object. For example is you want to associate an interface <code>IService</code> with implementation <code>Service</code> you would register it like this:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;IService, Service&gt;();\n</code></pre>\n<p>Or you could register multiple implementations for the same service:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;IService, MailService&gt;(&quot;Email&quot;);\ncontainer.RegisterType&lt;IService, WebService&gt;(&quot;WebMail&quot;);\ncontainer.RegisterType&lt;IService, SecureService&gt;(&quot;Encrypted&quot;);\n</code></pre>\n<p>For more information see &lt;xref:Tutorial.Registration.Mapping&gt;</p>\n<h2 id=\"lifetime-management\">Lifetime Management</h2>\n<p>Unity provides wide variety of lifetime managers <a href=\"xref:Unity.TypeLifetime\" data-linktype=\"external\">compatible</a> with type registrations. Each of these managers provide unique algorithm for instance management.</p>\n<p>In example above services are created on each request. In most cases it is desireable to create services only once. To create singleton services appropriate lifetime managers must be added to the registration:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;IService, MailService&gt;(&quot;Email&quot;, TypeLifetime.Singleton);\ncontainer.RegisterType&lt;IService, WebService&gt;(&quot;WebMail&quot;, TypeLifetime.Singleton);\ncontainer.RegisterType&lt;IService, SecureService&gt;(&quot;Encrypted&quot;, TypeLifetime.Singleton);\n</code></pre>\n<p>For more information about lifetime management see <a href=\"../../../lifetime/lifetime/\" data-linktype=\"relative-path\">Lifetime Management</a></p>\n<h2 id=\"creation-pipeline\">Creation Pipeline</h2>\n<p>Unity instantiates an objects by creating a resolver pipeline and executing it with passed in injection values. Each pipeline consists of a several steps with each step performing part of the initialization.</p>\n<p>How the pipeline is assembled and what values are injected is controlled by collection of <a href=\"xref:Unity.Injection.InjectionMember\" data-linktype=\"external\">Injection Member</a> objects passed to registration method. The normal steps of the object creation process are:</p>\n<h2 id=\"injection-instructions\">Injection Instructions</h2>\n<p>During the registration you could Configure the container to select certain constructor, initialize properties and fields, call methods, and inject values and instructions for dependencies. All this is done by passing appropriate <a href=\"xref:Unity.Injection\" data-linktype=\"external\">Injection Members</a> to the registration. For more information see:</p>\n<ul>\n<li><a href=\"../constructor/constructor/\" data-linktype=\"relative-path\">Constructor invocation and injection</a></li>\n<li><a href=\"../field/\" data-linktype=\"relative-path\">Fields injection</a></li>\n<li><a href=\"../property/\" data-linktype=\"relative-path\">Properties injection</a></li>\n<li><a href=\"../method/\" data-linktype=\"relative-path\">Method(s) invocation and injection</a></li>\n</ul>\n","content_git_url":"https://github.com/unitycontainer/documentation/blob/develop/tutorials/registration/Type/registration.md","depot_name":".","document_id":"78bfd467-15ee-c33f-03fe-7bf8e5fa4acf","document_version_independent_id":"6550f935-d2d3-ea0d-a876-56627397815d","gitcommit":"https://github.com/unitycontainer/documentation/blob/2db5f0db6ca55d08f45572868da0e40bb64f7bc0/tutorials/registration/Type/registration.md","locale":"en-us","original_content_git_url":"https://github.com/unitycontainer/documentation/blob/develop/tutorials/registration/Type/registration.md","original_content_git_url_template":"{repo}/blob/{branch}/tutorials/registration/Type/registration.md","rawTitle":"<h1 id=\"type-registration\">Type Registration</h1>","search.ms_docsetname":"","search.ms_product":"","search.ms_sitename":"Docs","site_name":"Docs","title":"Type Registration","uid":"Tutorial.Registration.Type","updated_at":"2019-03-11 12:52 AM","wordCount":576},"metadata":"<meta name=\"canonical_url\" content=\"https:///en-us/tutorials/registration/type/registration/\" />\r\n<meta name=\"conceptual\" content=\"\n&lt;p&gt;Type registration is where all the Unity magic is happening. It provides complete and flexible control of all aspects of type creation and management.&lt;/p&gt;\n&lt;p&gt;When a &lt;a href=&quot;xref:System.Type&quot; data-linktype=&quot;external&quot;&gt;Type&lt;/a&gt; is registered Unity creates a contract (a registration) consisting of a &lt;strong&gt;Type&lt;/strong&gt;, a &lt;strong&gt;Name&lt;/strong&gt;, and instructions on how this contract should be fulfilled when requested.&lt;/p&gt;\n&lt;h2 id=&quot;minimum-registration-requirements&quot;&gt;Minimum Registration Requirements&lt;/h2&gt;\n&lt;p&gt;The only required part of the registration is a registered &lt;a href=&quot;xref:System.Type&quot; data-linktype=&quot;external&quot;&gt;Type&lt;/a&gt; itself. Theoretically you could register a &lt;a href=&quot;xref:System.Type&quot; data-linktype=&quot;external&quot;&gt;Type&lt;/a&gt; like this:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;container.RegisterType&amp;lt;Service&amp;gt;();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This would tell the container to use all defaults when creating &lt;code&gt;Service&lt;/code&gt;. Registrations like this do not make much sense. If creation process does not require any customization, all that time spent on registering such &lt;a href=&quot;xref:System.Type&quot; data-linktype=&quot;external&quot;&gt;Type&lt;/a&gt; is wasted. It is measurably faster to resolve a plain &lt;a href=&quot;xref:System.Type&quot; data-linktype=&quot;external&quot;&gt;Type&lt;/a&gt; from the container if it is not registered at all.&lt;/p&gt;\n&lt;p&gt;When a &lt;a href=&quot;xref:System.Type&quot; data-linktype=&quot;external&quot;&gt;Type&lt;/a&gt; is annotated with injection attributes it does not require registration either. If you are satisfied with annotated selections, appropriate constructor and all other members are annotated, and you do not require lifetime management for created instances, the &lt;a href=&quot;xref:System.Type&quot; data-linktype=&quot;external&quot;&gt;Type&lt;/a&gt; should not be registered.&lt;/p&gt;\n&lt;p&gt;You should only register types if at least one of the following is true:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Contract/Registration requires a Name&lt;/li&gt;\n&lt;li&gt;Require a mapping between service and implementation types&lt;/li&gt;\n&lt;li&gt;Require lifetime policy other than transient&lt;/li&gt;\n&lt;li&gt;Need to override injection annotated with attribute(s)&lt;/li&gt;\n&lt;li&gt;Nondefault constructor should be selected&lt;/li&gt;\n&lt;li&gt;Properties or fields should be injected&lt;/li&gt;\n&lt;li&gt;Method(s) should be called during initialization&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=&quot;creating-registration-contracts&quot;&gt;Creating Registration Contracts&lt;/h2&gt;\n&lt;p&gt;Simplest form of a contract is a registration without a Name ( the Name is &lt;code&gt;null&lt;/code&gt; ). This type of registration is called &lt;code&gt;default&lt;/code&gt; and in some cases is used as a prototype during resolution of Generic types (hence name &lt;code&gt;default&lt;/code&gt;).&lt;/p&gt;\n&lt;p&gt;A contract could have a Name. The Name could be any arbitrary string of one or more characters. The simple named contract could be registered like this:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;container.RegisterType&amp;lt;Service&amp;gt;(&amp;quot;Contract Name&amp;quot;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;NOTE&quot;&gt;\n&lt;h5&gt;NOTE&lt;/h5&gt;\n&lt;p&gt;It is not recommended to use empty strings as names.&lt;/p&gt;\n&lt;/div&gt;\n&lt;h2 id=&quot;creating-type-mapping&quot;&gt;Creating Type Mapping&lt;/h2&gt;\n&lt;p&gt;A mapping instructs Unity on how to satisfy the contract and what implementation &lt;a href=&quot;xref:System.Type&quot; data-linktype=&quot;external&quot;&gt;Type&lt;/a&gt; should be used to create an object. For example is you want to associate an interface &lt;code&gt;IService&lt;/code&gt; with implementation &lt;code&gt;Service&lt;/code&gt; you would register it like this:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;container.RegisterType&amp;lt;IService, Service&amp;gt;();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Or you could register multiple implementations for the same service:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;container.RegisterType&amp;lt;IService, MailService&amp;gt;(&amp;quot;Email&amp;quot;);\ncontainer.RegisterType&amp;lt;IService, WebService&amp;gt;(&amp;quot;WebMail&amp;quot;);\ncontainer.RegisterType&amp;lt;IService, SecureService&amp;gt;(&amp;quot;Encrypted&amp;quot;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For more information see &amp;lt;xref:Tutorial.Registration.Mapping&amp;gt;&lt;/p&gt;\n&lt;h2 id=&quot;lifetime-management&quot;&gt;Lifetime Management&lt;/h2&gt;\n&lt;p&gt;Unity provides wide variety of lifetime managers &lt;a href=&quot;xref:Unity.TypeLifetime&quot; data-linktype=&quot;external&quot;&gt;compatible&lt;/a&gt; with type registrations. Each of these managers provide unique algorithm for instance management.&lt;/p&gt;\n&lt;p&gt;In example above services are created on each request. In most cases it is desireable to create services only once. To create singleton services appropriate lifetime managers must be added to the registration:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;container.RegisterType&amp;lt;IService, MailService&amp;gt;(&amp;quot;Email&amp;quot;, TypeLifetime.Singleton);\ncontainer.RegisterType&amp;lt;IService, WebService&amp;gt;(&amp;quot;WebMail&amp;quot;, TypeLifetime.Singleton);\ncontainer.RegisterType&amp;lt;IService, SecureService&amp;gt;(&amp;quot;Encrypted&amp;quot;, TypeLifetime.Singleton);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For more information about lifetime management see &lt;a href=&quot;../../../lifetime/lifetime/&quot; data-linktype=&quot;relative-path&quot;&gt;Lifetime Management&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=&quot;creation-pipeline&quot;&gt;Creation Pipeline&lt;/h2&gt;\n&lt;p&gt;Unity instantiates an objects by creating a resolver pipeline and executing it with passed in injection values. Each pipeline consists of a several steps with each step performing part of the initialization.&lt;/p&gt;\n&lt;p&gt;How the pipeline is assembled and what values are injected is controlled by collection of &lt;a href=&quot;xref:Unity.Injection.InjectionMember&quot; data-linktype=&quot;external&quot;&gt;Injection Member&lt;/a&gt; objects passed to registration method. The normal steps of the object creation process are:&lt;/p&gt;\n&lt;h2 id=&quot;injection-instructions&quot;&gt;Injection Instructions&lt;/h2&gt;\n&lt;p&gt;During the registration you could Configure the container to select certain constructor, initialize properties and fields, call methods, and inject values and instructions for dependencies. All this is done by passing appropriate &lt;a href=&quot;xref:Unity.Injection&quot; data-linktype=&quot;external&quot;&gt;Injection Members&lt;/a&gt; to the registration. For more information see:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;../constructor/constructor/&quot; data-linktype=&quot;relative-path&quot;&gt;Constructor invocation and injection&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;../field/&quot; data-linktype=&quot;relative-path&quot;&gt;Fields injection&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;../property/&quot; data-linktype=&quot;relative-path&quot;&gt;Properties injection&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;../method/&quot; data-linktype=&quot;relative-path&quot;&gt;Method(s) invocation and injection&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\" />\r\n<meta name=\"content_git_url\" content=\"https://github.com/unitycontainer/documentation/blob/develop/tutorials/registration/Type/registration.md\" />\r\n<meta name=\"depot_name\" content=\".\" />\r\n<meta name=\"document_id\" content=\"78bfd467-15ee-c33f-03fe-7bf8e5fa4acf\" />\r\n<meta name=\"document_version_independent_id\" content=\"6550f935-d2d3-ea0d-a876-56627397815d\" />\r\n<meta name=\"gitcommit\" content=\"https://github.com/unitycontainer/documentation/blob/2db5f0db6ca55d08f45572868da0e40bb64f7bc0/tutorials/registration/Type/registration.md\" />\r\n<meta name=\"locale\" content=\"en-us\" />\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/unitycontainer/documentation/blob/develop/tutorials/registration/Type/registration.md\" />\r\n<meta name=\"original_content_git_url_template\" content=\"{repo}/blob/{branch}/tutorials/registration/Type/registration.md\" />\r\n<meta name=\"rawTitle\" content=\"&lt;h1 id=&quot;type-registration&quot;&gt;Type Registration&lt;/h1&gt;\" />\r\n<meta name=\"search.ms_docsetname\" content=\"\" />\r\n<meta name=\"search.ms_product\" content=\"\" />\r\n<meta name=\"search.ms_sitename\" content=\"Docs\" />\r\n<meta name=\"site_name\" content=\"Docs\" />\r\n<meta name=\"title\" content=\"Type Registration\" />\r\n<meta name=\"uid\" content=\"Tutorial.Registration.Type\" />\r\n<meta name=\"updated_at\" content=\"2019-03-11 12:52 AM\" />\r\n<meta name=\"wordCount\" content=\"576\" />\r\n<meta name=\"is_dynamic_rendering\" content=\"true\" />\r\n","theme_rel":"..\\..\\..\\..\\_themes"}