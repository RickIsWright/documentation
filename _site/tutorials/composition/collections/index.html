{"content":"\n<p>Unity supports creating multiple registration of the same type by adding a name to the registration. It is useful if you want to register different services of the same type. For example, if you have multiple printers and you want them all to be available to consumers you would register them like this:</p>\n<pre><code class=\"lang-cs\">container.RegisterInstance&lt;IPrinter&gt;(printer); // default printer\ncontainer.RegisterInstance&lt;IPrinter&gt;(printer1,   &quot;Office Printer&quot;);\ncontainer.RegisterInstance&lt;IPrinter&gt;(printer2,   &quot;Printer at the deli on the street corner&quot;);\ncontainer.RegisterType&lt;IPrinter, NeighborPrinter&gt;(&quot;Office printer near me&quot;);\n</code></pre>\n<p>When you want to obtain a list of all the registered objects of a specific type, <code>IPrinter</code> in this case, you can use the array <code>T[]</code> or <code>IEnumerable&lt;T&gt;</code> of that type. The difference between array and enumerable resolution is that array only returns named (nondefault name) registrations where enumerable always returns all, named and unnamed registrations.</p>\n<h2 id=\"resolving-array-t\">Resolving array <code>T[]</code></h2>\n<p>When resolving array of a type, Unity will return an array containing only types registered with nondefault (other than <code>null</code>) names. In example above call to <code>Resolve</code> will return array of only three elements:</p>\n<pre><code class=\"lang-cs\">IPrinter[] printers = container.Resolve&lt;IPrinter[]&gt;();\nAssert(3 == printers.Length)\n</code></pre>\n<p>Instance <strong>printer</strong> will not be returned because it was registered with no name.</p>\n<h2 id=\"resolving-ienumerablet\">Resolving <code>IEnumerable&lt;T&gt;</code></h2>\n<p><code>IEnumerable&lt;T&gt;</code> returns an enumerable containing all registrations of type T, including default (with name <code>null</code>) registrations. In example above it will return all four registrations:</p>\n<pre><code class=\"lang-cs\">IPrinter[] printers = container.Resolve&lt;IEnumerable&lt;IPrinter&gt;&gt;();\nAssert(4 == printers.Count())\n</code></pre>\n<h2 id=\"resolving-listt-of-types\">Resolving <code>List&lt;T&gt;</code> of types</h2>\n<p>Unity does not have any special provisions to support <code>List&lt;T&gt;</code> but because <code>List</code> type's longest exposed constructor is</p>\n<pre><code class=\"lang-cs\">public List(IEnumerable&lt;T&gt; items)\n</code></pre>\n<p>Unity is able to resolve <code>List&lt;T&gt;</code>. Consider this example:</p>\n<pre><code class=\"lang-cs\">var printers = container.Resolve&lt;List&lt;IPrinter&gt;&gt;();\nAssert(4 == printers.Count)\n</code></pre>\n<p>Unity creates type <code>List&lt;IPrinter&gt;</code> and during initialization selects longest constructor it can satisfy with dependencies (<code>List(IEnumerable&lt;T&gt; items)</code>). It crates the enumeration and passes it to List constructor. Resulting instance is a list of all registrations of that type.</p>\n","page":{"_appFaviconPath":"images/favicon.png","_appFooter":"<span>Copyright &copy; 2008â€“2019 <strong>Unity Container</strong> project</span>","_appLogoPath":"images/logo.svg","_appTitle":"Unity Container","_op_canonicalUrlPrefix":"https://en-us/","_op_gitContributorInformation":{"update_at":"4/30/2019","updated_at_date_time":"2019-04-30T00:00:11Z"},"_path":"tutorials/composition/collections/index.html","_tocRel":"../../toc.json","canonical_url":"https:///en-us/tutorials/composition/collections/","conceptual":"\n<p>Unity supports creating multiple registration of the same type by adding a name to the registration. It is useful if you want to register different services of the same type. For example, if you have multiple printers and you want them all to be available to consumers you would register them like this:</p>\n<pre><code class=\"lang-cs\">container.RegisterInstance&lt;IPrinter&gt;(printer); // default printer\ncontainer.RegisterInstance&lt;IPrinter&gt;(printer1,   &quot;Office Printer&quot;);\ncontainer.RegisterInstance&lt;IPrinter&gt;(printer2,   &quot;Printer at the deli on the street corner&quot;);\ncontainer.RegisterType&lt;IPrinter, NeighborPrinter&gt;(&quot;Office printer near me&quot;);\n</code></pre>\n<p>When you want to obtain a list of all the registered objects of a specific type, <code>IPrinter</code> in this case, you can use the array <code>T[]</code> or <code>IEnumerable&lt;T&gt;</code> of that type. The difference between array and enumerable resolution is that array only returns named (nondefault name) registrations where enumerable always returns all, named and unnamed registrations.</p>\n<h2 id=\"resolving-array-t\">Resolving array <code>T[]</code></h2>\n<p>When resolving array of a type, Unity will return an array containing only types registered with nondefault (other than <code>null</code>) names. In example above call to <code>Resolve</code> will return array of only three elements:</p>\n<pre><code class=\"lang-cs\">IPrinter[] printers = container.Resolve&lt;IPrinter[]&gt;();\nAssert(3 == printers.Length)\n</code></pre>\n<p>Instance <strong>printer</strong> will not be returned because it was registered with no name.</p>\n<h2 id=\"resolving-ienumerablet\">Resolving <code>IEnumerable&lt;T&gt;</code></h2>\n<p><code>IEnumerable&lt;T&gt;</code> returns an enumerable containing all registrations of type T, including default (with name <code>null</code>) registrations. In example above it will return all four registrations:</p>\n<pre><code class=\"lang-cs\">IPrinter[] printers = container.Resolve&lt;IEnumerable&lt;IPrinter&gt;&gt;();\nAssert(4 == printers.Count())\n</code></pre>\n<h2 id=\"resolving-listt-of-types\">Resolving <code>List&lt;T&gt;</code> of types</h2>\n<p>Unity does not have any special provisions to support <code>List&lt;T&gt;</code> but because <code>List</code> type's longest exposed constructor is</p>\n<pre><code class=\"lang-cs\">public List(IEnumerable&lt;T&gt; items)\n</code></pre>\n<p>Unity is able to resolve <code>List&lt;T&gt;</code>. Consider this example:</p>\n<pre><code class=\"lang-cs\">var printers = container.Resolve&lt;List&lt;IPrinter&gt;&gt;();\nAssert(4 == printers.Count)\n</code></pre>\n<p>Unity creates type <code>List&lt;IPrinter&gt;</code> and during initialization selects longest constructor it can satisfy with dependencies (<code>List(IEnumerable&lt;T&gt; items)</code>). It crates the enumeration and passes it to List constructor. Resulting instance is a list of all registrations of that type.</p>\n","content_git_url":"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Composition/collections.md","depot_name":".","document_id":"0884b99e-0a93-edc3-f12f-ad8b3a65a047","document_version_independent_id":"e03b645c-3edf-6832-3486-73089b8efedc","gitcommit":"https://github.com/unitycontainer/documentation/blob/704b5031aaedb4ba2af139c76a605c3c9b409600/tutorials/Composition/collections.md","locale":"en-us","original_content_git_url":"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Composition/collections.md","original_content_git_url_template":"{repo}/blob/{branch}/tutorials/Composition/collections.md","rawTitle":"<h1 id=\"resolving-collections-of-objects-of-a-particular-type\">Resolving collections of Objects of a Particular Type</h1>","search.ms_docsetname":"","search.ms_product":"","search.ms_sitename":"Docs","site_name":"Docs","title":"Collections","uid":"Tutorial.Collections","updated_at":"2019-04-30 12:00 AM","wordCount":300},"metadata":"<meta name=\"canonical_url\" content=\"https:///en-us/tutorials/composition/collections/\" />\r\n<meta name=\"conceptual\" content=\"\n&lt;p&gt;Unity supports creating multiple registration of the same type by adding a name to the registration. It is useful if you want to register different services of the same type. For example, if you have multiple printers and you want them all to be available to consumers you would register them like this:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;container.RegisterInstance&amp;lt;IPrinter&amp;gt;(printer); // default printer\ncontainer.RegisterInstance&amp;lt;IPrinter&amp;gt;(printer1,   &amp;quot;Office Printer&amp;quot;);\ncontainer.RegisterInstance&amp;lt;IPrinter&amp;gt;(printer2,   &amp;quot;Printer at the deli on the street corner&amp;quot;);\ncontainer.RegisterType&amp;lt;IPrinter, NeighborPrinter&amp;gt;(&amp;quot;Office printer near me&amp;quot;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;When you want to obtain a list of all the registered objects of a specific type, &lt;code&gt;IPrinter&lt;/code&gt; in this case, you can use the array &lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; of that type. The difference between array and enumerable resolution is that array only returns named (nondefault name) registrations where enumerable always returns all, named and unnamed registrations.&lt;/p&gt;\n&lt;h2 id=&quot;resolving-array-t&quot;&gt;Resolving array &lt;code&gt;T[]&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;When resolving array of a type, Unity will return an array containing only types registered with nondefault (other than &lt;code&gt;null&lt;/code&gt;) names. In example above call to &lt;code&gt;Resolve&lt;/code&gt; will return array of only three elements:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;IPrinter[] printers = container.Resolve&amp;lt;IPrinter[]&amp;gt;();\nAssert(3 == printers.Length)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Instance &lt;strong&gt;printer&lt;/strong&gt; will not be returned because it was registered with no name.&lt;/p&gt;\n&lt;h2 id=&quot;resolving-ienumerablet&quot;&gt;Resolving &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; returns an enumerable containing all registrations of type T, including default (with name &lt;code&gt;null&lt;/code&gt;) registrations. In example above it will return all four registrations:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;IPrinter[] printers = container.Resolve&amp;lt;IEnumerable&amp;lt;IPrinter&amp;gt;&amp;gt;();\nAssert(4 == printers.Count())\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=&quot;resolving-listt-of-types&quot;&gt;Resolving &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; of types&lt;/h2&gt;\n&lt;p&gt;Unity does not have any special provisions to support &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; but because &lt;code&gt;List&lt;/code&gt; type&#39;s longest exposed constructor is&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;public List(IEnumerable&amp;lt;T&amp;gt; items)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Unity is able to resolve &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;. Consider this example:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;var printers = container.Resolve&amp;lt;List&amp;lt;IPrinter&amp;gt;&amp;gt;();\nAssert(4 == printers.Count)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Unity creates type &lt;code&gt;List&amp;lt;IPrinter&amp;gt;&lt;/code&gt; and during initialization selects longest constructor it can satisfy with dependencies (&lt;code&gt;List(IEnumerable&amp;lt;T&amp;gt; items)&lt;/code&gt;). It crates the enumeration and passes it to List constructor. Resulting instance is a list of all registrations of that type.&lt;/p&gt;\n\" />\r\n<meta name=\"content_git_url\" content=\"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Composition/collections.md\" />\r\n<meta name=\"depot_name\" content=\".\" />\r\n<meta name=\"document_id\" content=\"0884b99e-0a93-edc3-f12f-ad8b3a65a047\" />\r\n<meta name=\"document_version_independent_id\" content=\"e03b645c-3edf-6832-3486-73089b8efedc\" />\r\n<meta name=\"gitcommit\" content=\"https://github.com/unitycontainer/documentation/blob/704b5031aaedb4ba2af139c76a605c3c9b409600/tutorials/Composition/collections.md\" />\r\n<meta name=\"locale\" content=\"en-us\" />\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Composition/collections.md\" />\r\n<meta name=\"original_content_git_url_template\" content=\"{repo}/blob/{branch}/tutorials/Composition/collections.md\" />\r\n<meta name=\"rawTitle\" content=\"&lt;h1 id=&quot;resolving-collections-of-objects-of-a-particular-type&quot;&gt;Resolving collections of Objects of a Particular Type&lt;/h1&gt;\" />\r\n<meta name=\"search.ms_docsetname\" content=\"\" />\r\n<meta name=\"search.ms_product\" content=\"\" />\r\n<meta name=\"search.ms_sitename\" content=\"Docs\" />\r\n<meta name=\"site_name\" content=\"Docs\" />\r\n<meta name=\"title\" content=\"Collections\" />\r\n<meta name=\"uid\" content=\"Tutorial.Collections\" />\r\n<meta name=\"updated_at\" content=\"2019-04-30 12:00 AM\" />\r\n<meta name=\"wordCount\" content=\"300\" />\r\n<meta name=\"is_dynamic_rendering\" content=\"true\" />\r\n","theme_rel":"..\\..\\..\\_themes"}