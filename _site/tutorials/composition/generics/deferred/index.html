{"content":"\n<p>Unity provides a technique to facilitate holding a reference to an object you need, but do not want to construct right away. You wish to defer resolution of the object. Instead of creating a factory for the type and injecting the factory into your class, then using it to create the type you want you can use the .NET standard type Func<t> (C#) or Func(Of T) (Visual Basic) with the Resolve method. This returns a delegate that, when invoked, calls into the container and returns an instance of the specified type (in this case, T).<p>\n<p>You can even create a delegate in this way without creating a registration or mapping for the specified type in the container if you wish. Because the resolve action only takes place when you invoke the delegate, subsequent registrations added to the container are available when the target object is resolved. This means that you can manipulate the registrations and mappings in the container at any point before you resolve the target object (although you can obviously register the type before you create the delegate if you prefer).</p>\n<p>For example, you can create a delegate for a component named MyClass, and then register a mapping for it and perform deferred resolution when required using the following code.</p>\n<pre><code class=\"lang-cs\">// Create a Unity container\nIUnityContainer myContainer = new UnityContainer();\n\n// Create a delegate for the IMyClass interface type\nvar resolver = myContainer.Resolve&lt;Func&lt;IMyClass&gt;&gt;();\n\n// ... other code here...\n\n// Register a mapping for the IMyClass interface to the MyClass type\nmyContainer.RegisterType&lt;IMyClass, MyClass&gt;();\n\n// Resolve the mapped target object\nIMyClass myClassInstance = resolver();\n</code></pre>\n<p>You can use this approach when you resolve the type using the Resolve method, or you can specify the delegate when you configure constructor, property setter, or method call injection. You can also use named (non-default) registrations by including the registration name in the call to the Resolve method and the RegisterType method, just as you would when using these methods for non-deferred resolution.</p>\n<p>In addition, you can use this feature to perform deferred resolution of multiple named registrations, as an alternative to using the ResolveAll method. For example, if you have multiple named registrations for the IMyClass interface to suitable concrete types, you can obtain a collection of the resolved types. The following code illustrates this.</p>\n<pre><code class=\"lang-cs\">// Create a Unity container\nIUnityContainer myContainer = new UnityContainer();\n\n// Create an IEnumerable resolver for the IMyClass interface type\nvar resolver = myContainer.Resolve&lt;Func&lt;IEnumerable&lt;IMyClass&gt;&gt;&gt;();\n\n// ... other code here...\n\n// Register mappings for the IMyClass interface to appropriate concrete types\nmyContainer.RegisterType&lt;IMyClass, FirstClass&gt;(&quot;First&quot;);\nmyContainer.RegisterType&lt;IMyClass, SecondClass&gt;(&quot;Second&quot;);\nmyContainer.RegisterType&lt;IMyClass, ThidClass&gt;(&quot;Third&quot;);\n\n// Resolve a collection of the mapped target objects\nIEnumerable&lt;IMyClass&gt; myClassInstances = resolver();\n</code></pre>\n<p>You can also use the deferred resolver to resolve instance registrations. For example, the following code shows how you can resolve an IEnumerable collection of string values.</p>\n<pre><code class=\"lang-cs\">// Create a Unity container\nIUnityContainer myContainer = new UnityContainer();\n\n// Create an IEnumerable resolver for string instance registrations\nvar resolver = myContainer.Resolve&lt;Func&lt;IEnumerable&lt;string&gt;&gt;&gt;();\n\n// ... other code here...\n\n// Register mappings for the IMyClass interface to appropriate concrete types\nmyContainer.RegisterInstance(&quot;one&quot;, &quot;FirstString&quot;);\nmyContainer.RegisterInstance(&quot;two&quot;, &quot;SecondString&quot;);\nmyContainer.RegisterInstance(&quot;three&quot;, &quot;ThirdString&quot;);\n\n// Resolve a collection of the strings\nIEnumerable&lt;string&gt; myStringInstances = resolver();\n</code></pre>\n</t>","page":{"_appFaviconPath":"images/favicon.png","_appFooter":"<span>Copyright &copy; 2008â€“2019 <strong>Unity Container</strong> project</span>","_appLogoPath":"images/logo.svg","_appTitle":"Unity Container","_op_canonicalUrlPrefix":"https://en-us/","_op_gitContributorInformation":{"update_at":"4/30/2019","updated_at_date_time":"2019-04-30T00:00:11Z"},"_path":"tutorials/composition/generics/deferred/index.html","_tocRel":"../../../toc.json","canonical_url":"https:///en-us/tutorials/composition/generics/deferred/","conceptual":"\n<p>Unity provides a technique to facilitate holding a reference to an object you need, but do not want to construct right away. You wish to defer resolution of the object. Instead of creating a factory for the type and injecting the factory into your class, then using it to create the type you want you can use the .NET standard type Func<t> (C#) or Func(Of T) (Visual Basic) with the Resolve method. This returns a delegate that, when invoked, calls into the container and returns an instance of the specified type (in this case, T).<p>\n<p>You can even create a delegate in this way without creating a registration or mapping for the specified type in the container if you wish. Because the resolve action only takes place when you invoke the delegate, subsequent registrations added to the container are available when the target object is resolved. This means that you can manipulate the registrations and mappings in the container at any point before you resolve the target object (although you can obviously register the type before you create the delegate if you prefer).</p>\n<p>For example, you can create a delegate for a component named MyClass, and then register a mapping for it and perform deferred resolution when required using the following code.</p>\n<pre><code class=\"lang-cs\">// Create a Unity container\nIUnityContainer myContainer = new UnityContainer();\n\n// Create a delegate for the IMyClass interface type\nvar resolver = myContainer.Resolve&lt;Func&lt;IMyClass&gt;&gt;();\n\n// ... other code here...\n\n// Register a mapping for the IMyClass interface to the MyClass type\nmyContainer.RegisterType&lt;IMyClass, MyClass&gt;();\n\n// Resolve the mapped target object\nIMyClass myClassInstance = resolver();\n</code></pre>\n<p>You can use this approach when you resolve the type using the Resolve method, or you can specify the delegate when you configure constructor, property setter, or method call injection. You can also use named (non-default) registrations by including the registration name in the call to the Resolve method and the RegisterType method, just as you would when using these methods for non-deferred resolution.</p>\n<p>In addition, you can use this feature to perform deferred resolution of multiple named registrations, as an alternative to using the ResolveAll method. For example, if you have multiple named registrations for the IMyClass interface to suitable concrete types, you can obtain a collection of the resolved types. The following code illustrates this.</p>\n<pre><code class=\"lang-cs\">// Create a Unity container\nIUnityContainer myContainer = new UnityContainer();\n\n// Create an IEnumerable resolver for the IMyClass interface type\nvar resolver = myContainer.Resolve&lt;Func&lt;IEnumerable&lt;IMyClass&gt;&gt;&gt;();\n\n// ... other code here...\n\n// Register mappings for the IMyClass interface to appropriate concrete types\nmyContainer.RegisterType&lt;IMyClass, FirstClass&gt;(&quot;First&quot;);\nmyContainer.RegisterType&lt;IMyClass, SecondClass&gt;(&quot;Second&quot;);\nmyContainer.RegisterType&lt;IMyClass, ThidClass&gt;(&quot;Third&quot;);\n\n// Resolve a collection of the mapped target objects\nIEnumerable&lt;IMyClass&gt; myClassInstances = resolver();\n</code></pre>\n<p>You can also use the deferred resolver to resolve instance registrations. For example, the following code shows how you can resolve an IEnumerable collection of string values.</p>\n<pre><code class=\"lang-cs\">// Create a Unity container\nIUnityContainer myContainer = new UnityContainer();\n\n// Create an IEnumerable resolver for string instance registrations\nvar resolver = myContainer.Resolve&lt;Func&lt;IEnumerable&lt;string&gt;&gt;&gt;();\n\n// ... other code here...\n\n// Register mappings for the IMyClass interface to appropriate concrete types\nmyContainer.RegisterInstance(&quot;one&quot;, &quot;FirstString&quot;);\nmyContainer.RegisterInstance(&quot;two&quot;, &quot;SecondString&quot;);\nmyContainer.RegisterInstance(&quot;three&quot;, &quot;ThirdString&quot;);\n\n// Resolve a collection of the strings\nIEnumerable&lt;string&gt; myStringInstances = resolver();\n</code></pre>\n</t>","content_git_url":"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Composition/Generics/deferred.md","depot_name":".","document_id":"a1f92544-a7e3-3af7-c90f-d602719ebcfa","document_version_independent_id":"ec0143ad-09ff-c2bb-f179-d04c151dfa62","gitcommit":"https://github.com/unitycontainer/documentation/blob/704b5031aaedb4ba2af139c76a605c3c9b409600/tutorials/Composition/Generics/deferred.md","locale":"en-us","original_content_git_url":"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Composition/Generics/deferred.md","original_content_git_url_template":"{repo}/blob/{branch}/tutorials/Composition/Generics/deferred.md","rawTitle":"<h1 id=\"deferring-the-resolution-of-objects\">Deferring the Resolution of Objects</h1>","search.ms_docsetname":"","search.ms_product":"","search.ms_sitename":"Docs","site_name":"Docs","title":"Deferred Resolution","uid":"Tutorial.Deferred","updated_at":"2019-04-30 12:00 AM","wordCount":520},"metadata":"<meta name=\"canonical_url\" content=\"https:///en-us/tutorials/composition/generics/deferred/\" />\r\n<meta name=\"conceptual\" content=\"\n&lt;p&gt;Unity provides a technique to facilitate holding a reference to an object you need, but do not want to construct right away. You wish to defer resolution of the object. Instead of creating a factory for the type and injecting the factory into your class, then using it to create the type you want you can use the .NET standard type Func&lt;t&gt; (C#) or Func(Of T) (Visual Basic) with the Resolve method. This returns a delegate that, when invoked, calls into the container and returns an instance of the specified type (in this case, T).&lt;p&gt;\n&lt;p&gt;You can even create a delegate in this way without creating a registration or mapping for the specified type in the container if you wish. Because the resolve action only takes place when you invoke the delegate, subsequent registrations added to the container are available when the target object is resolved. This means that you can manipulate the registrations and mappings in the container at any point before you resolve the target object (although you can obviously register the type before you create the delegate if you prefer).&lt;/p&gt;\n&lt;p&gt;For example, you can create a delegate for a component named MyClass, and then register a mapping for it and perform deferred resolution when required using the following code.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;// Create a Unity container\nIUnityContainer myContainer = new UnityContainer();\n\n// Create a delegate for the IMyClass interface type\nvar resolver = myContainer.Resolve&amp;lt;Func&amp;lt;IMyClass&amp;gt;&amp;gt;();\n\n// ... other code here...\n\n// Register a mapping for the IMyClass interface to the MyClass type\nmyContainer.RegisterType&amp;lt;IMyClass, MyClass&amp;gt;();\n\n// Resolve the mapped target object\nIMyClass myClassInstance = resolver();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can use this approach when you resolve the type using the Resolve method, or you can specify the delegate when you configure constructor, property setter, or method call injection. You can also use named (non-default) registrations by including the registration name in the call to the Resolve method and the RegisterType method, just as you would when using these methods for non-deferred resolution.&lt;/p&gt;\n&lt;p&gt;In addition, you can use this feature to perform deferred resolution of multiple named registrations, as an alternative to using the ResolveAll method. For example, if you have multiple named registrations for the IMyClass interface to suitable concrete types, you can obtain a collection of the resolved types. The following code illustrates this.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;// Create a Unity container\nIUnityContainer myContainer = new UnityContainer();\n\n// Create an IEnumerable resolver for the IMyClass interface type\nvar resolver = myContainer.Resolve&amp;lt;Func&amp;lt;IEnumerable&amp;lt;IMyClass&amp;gt;&amp;gt;&amp;gt;();\n\n// ... other code here...\n\n// Register mappings for the IMyClass interface to appropriate concrete types\nmyContainer.RegisterType&amp;lt;IMyClass, FirstClass&amp;gt;(&amp;quot;First&amp;quot;);\nmyContainer.RegisterType&amp;lt;IMyClass, SecondClass&amp;gt;(&amp;quot;Second&amp;quot;);\nmyContainer.RegisterType&amp;lt;IMyClass, ThidClass&amp;gt;(&amp;quot;Third&amp;quot;);\n\n// Resolve a collection of the mapped target objects\nIEnumerable&amp;lt;IMyClass&amp;gt; myClassInstances = resolver();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can also use the deferred resolver to resolve instance registrations. For example, the following code shows how you can resolve an IEnumerable collection of string values.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;// Create a Unity container\nIUnityContainer myContainer = new UnityContainer();\n\n// Create an IEnumerable resolver for string instance registrations\nvar resolver = myContainer.Resolve&amp;lt;Func&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt;&amp;gt;();\n\n// ... other code here...\n\n// Register mappings for the IMyClass interface to appropriate concrete types\nmyContainer.RegisterInstance(&amp;quot;one&amp;quot;, &amp;quot;FirstString&amp;quot;);\nmyContainer.RegisterInstance(&amp;quot;two&amp;quot;, &amp;quot;SecondString&amp;quot;);\nmyContainer.RegisterInstance(&amp;quot;three&amp;quot;, &amp;quot;ThirdString&amp;quot;);\n\n// Resolve a collection of the strings\nIEnumerable&amp;lt;string&amp;gt; myStringInstances = resolver();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/t&gt;\" />\r\n<meta name=\"content_git_url\" content=\"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Composition/Generics/deferred.md\" />\r\n<meta name=\"depot_name\" content=\".\" />\r\n<meta name=\"document_id\" content=\"a1f92544-a7e3-3af7-c90f-d602719ebcfa\" />\r\n<meta name=\"document_version_independent_id\" content=\"ec0143ad-09ff-c2bb-f179-d04c151dfa62\" />\r\n<meta name=\"gitcommit\" content=\"https://github.com/unitycontainer/documentation/blob/704b5031aaedb4ba2af139c76a605c3c9b409600/tutorials/Composition/Generics/deferred.md\" />\r\n<meta name=\"locale\" content=\"en-us\" />\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Composition/Generics/deferred.md\" />\r\n<meta name=\"original_content_git_url_template\" content=\"{repo}/blob/{branch}/tutorials/Composition/Generics/deferred.md\" />\r\n<meta name=\"rawTitle\" content=\"&lt;h1 id=&quot;deferring-the-resolution-of-objects&quot;&gt;Deferring the Resolution of Objects&lt;/h1&gt;\" />\r\n<meta name=\"search.ms_docsetname\" content=\"\" />\r\n<meta name=\"search.ms_product\" content=\"\" />\r\n<meta name=\"search.ms_sitename\" content=\"Docs\" />\r\n<meta name=\"site_name\" content=\"Docs\" />\r\n<meta name=\"title\" content=\"Deferred Resolution\" />\r\n<meta name=\"uid\" content=\"Tutorial.Deferred\" />\r\n<meta name=\"updated_at\" content=\"2019-04-30 12:00 AM\" />\r\n<meta name=\"wordCount\" content=\"520\" />\r\n<meta name=\"is_dynamic_rendering\" content=\"true\" />\r\n","theme_rel":"..\\..\\..\\..\\_themes"}