{"content":"\n<p>Service to Implementation mapping is done during the service registration.</p>\n<h2 id=\"the-service-itself\">The Service Itself</h2>\n<p>The simplest type of registration is when service is registered by its own type. For Type and Instance registration you could do so by simply registering the type or the instance:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;Foo&gt;();\ncontainer.RegisterInstance(new Foo());\n</code></pre>\n<p>A factory has to specify type it is registered under:</p>\n<pre><code class=\"lang-cs\">container.RegisterFactory&lt;Foo&gt;((c, t, n) =&gt; new Foo());\n</code></pre>\n<h2 id=\"mapping-contract-to-implementation\">Mapping Contract to Implementation</h2>\n<p>When you map Registered type to implementation type you specify an service type first and implementation type second:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;IFoo, Foo&gt;();\ncontainer.RegisterInstance&lt;IFoo&gt;(new Foo());\n</code></pre>\n<p>In case of factory registration the container does not care how it is implemented by the factory, all it cares is how it is registered:</p>\n<pre><code class=\"lang-cs\">container.RegisterFactory&lt;IFoo&gt;((c, t, n) =&gt; new Foo());\n</code></pre>\n<h2 id=\"building-and-mapping-to-implementation\">Building and Mapping to Implementation</h2>\n<p>Mapping allows redirection to existing registrations and services as well as building new instances of implementation types.</p>\n<h3 id=\"mapping-to-existing-service\">Mapping to Existing Service</h3>\n<p>The Unity container supports a scenario where a mapping does not crate type itself but rather references existing service registered with the container. Consider the following:</p>\n<pre><code class=\"lang-cs\">public class Foo : IFoo1, IFoo2\n{\n    public Foo()\n    {\n    }\n\n    public Foo(object _)\n    {\n    }\n}\n\ncontainer.RegisterInstance&lt;IFoo&gt;(new Foo(), InstanceLifetime.Singleton);\n\ncontainer.RegisterType&lt;IFoo1, Foo&gt;();\n</code></pre>\n<p>The container has a registration for type <code>Foo</code>. When interface <code>IFoo1</code> is mapped to <code>Foo</code> it instructs the container to resolve the default implementation for the type <code>Foo</code>. Because the mapping does not provide any instructions how the type should be built, the default implementation, or existing registration should be used.</p>\n<p>So, when the container will be resolving <code>IFoo1</code> it will first check if <code>Foo</code> is already registered and will used the registration to satisfy the request.</p>\n<p>If a mapping references non existing service the container will try to build the service from the implementation type.</p>\n<h3 id=\"building-implementation-type\">Building Implementation Type</h3>\n<p>If the implementation type points to no existing registration or if an instance has to be created using certain rules, the container will create a new, independent pipeline and execute. So if you register <code>IFoo2</code> like this:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;IFoo2, Foo&gt;(Invoke.Constructor());\n</code></pre>\n<p>the Unity container will not redirect to <code>Foo</code> but will create a new instance of <code>Foo</code> and call default constructor.</p>\n","page":{"_appFaviconPath":"images/favicon.png","_appFooter":"<span>Copyright &copy; 2008â€“2019 <strong>Unity Container</strong> project</span>","_appLogoPath":"images/logo.svg","_appTitle":"Unity Container","_op_canonicalUrlPrefix":"https://en-us/","_op_gitContributorInformation":{"update_at":"4/30/2019","updated_at_date_time":"2019-04-30T01:18:55Z"},"_path":"tutorials/composition/mapping/implementation/index.html","_tocRel":"../../../toc.json","canonical_url":"https:///en-us/tutorials/composition/mapping/implementation/","conceptual":"\n<p>Service to Implementation mapping is done during the service registration.</p>\n<h2 id=\"the-service-itself\">The Service Itself</h2>\n<p>The simplest type of registration is when service is registered by its own type. For Type and Instance registration you could do so by simply registering the type or the instance:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;Foo&gt;();\ncontainer.RegisterInstance(new Foo());\n</code></pre>\n<p>A factory has to specify type it is registered under:</p>\n<pre><code class=\"lang-cs\">container.RegisterFactory&lt;Foo&gt;((c, t, n) =&gt; new Foo());\n</code></pre>\n<h2 id=\"mapping-contract-to-implementation\">Mapping Contract to Implementation</h2>\n<p>When you map Registered type to implementation type you specify an service type first and implementation type second:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;IFoo, Foo&gt;();\ncontainer.RegisterInstance&lt;IFoo&gt;(new Foo());\n</code></pre>\n<p>In case of factory registration the container does not care how it is implemented by the factory, all it cares is how it is registered:</p>\n<pre><code class=\"lang-cs\">container.RegisterFactory&lt;IFoo&gt;((c, t, n) =&gt; new Foo());\n</code></pre>\n<h2 id=\"building-and-mapping-to-implementation\">Building and Mapping to Implementation</h2>\n<p>Mapping allows redirection to existing registrations and services as well as building new instances of implementation types.</p>\n<h3 id=\"mapping-to-existing-service\">Mapping to Existing Service</h3>\n<p>The Unity container supports a scenario where a mapping does not crate type itself but rather references existing service registered with the container. Consider the following:</p>\n<pre><code class=\"lang-cs\">public class Foo : IFoo1, IFoo2\n{\n    public Foo()\n    {\n    }\n\n    public Foo(object _)\n    {\n    }\n}\n\ncontainer.RegisterInstance&lt;IFoo&gt;(new Foo(), InstanceLifetime.Singleton);\n\ncontainer.RegisterType&lt;IFoo1, Foo&gt;();\n</code></pre>\n<p>The container has a registration for type <code>Foo</code>. When interface <code>IFoo1</code> is mapped to <code>Foo</code> it instructs the container to resolve the default implementation for the type <code>Foo</code>. Because the mapping does not provide any instructions how the type should be built, the default implementation, or existing registration should be used.</p>\n<p>So, when the container will be resolving <code>IFoo1</code> it will first check if <code>Foo</code> is already registered and will used the registration to satisfy the request.</p>\n<p>If a mapping references non existing service the container will try to build the service from the implementation type.</p>\n<h3 id=\"building-implementation-type\">Building Implementation Type</h3>\n<p>If the implementation type points to no existing registration or if an instance has to be created using certain rules, the container will create a new, independent pipeline and execute. So if you register <code>IFoo2</code> like this:</p>\n<pre><code class=\"lang-cs\">container.RegisterType&lt;IFoo2, Foo&gt;(Invoke.Constructor());\n</code></pre>\n<p>the Unity container will not redirect to <code>Foo</code> but will create a new instance of <code>Foo</code> and call default constructor.</p>\n","content_git_url":"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Composition/Mapping/implementation.md","depot_name":".","document_id":"67e38e86-49da-e80c-aa14-d18939f99491","document_version_independent_id":"6916f8de-fba9-4c35-b3b8-6cc40a8e8412","gitcommit":"https://github.com/unitycontainer/documentation/blob/ba6c8d58ec404ad0451d4a77b857483b11fc2a78/tutorials/Composition/Mapping/implementation.md","locale":"en-us","original_content_git_url":"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Composition/Mapping/implementation.md","original_content_git_url_template":"{repo}/blob/{branch}/tutorials/Composition/Mapping/implementation.md","rawTitle":"<h1 id=\"service-to-implementation-mapping\">Service to Implementation Mapping</h1>","search.ms_docsetname":"","search.ms_product":"","search.ms_sitename":"Docs","site_name":"Docs","title":"Service to Implementation Mapping","uid":"Tutorial.Mapping.Implementation","updated_at":"2019-04-30 01:18 AM","wordCount":351},"metadata":"<meta name=\"canonical_url\" content=\"https:///en-us/tutorials/composition/mapping/implementation/\" />\r\n<meta name=\"conceptual\" content=\"\n&lt;p&gt;Service to Implementation mapping is done during the service registration.&lt;/p&gt;\n&lt;h2 id=&quot;the-service-itself&quot;&gt;The Service Itself&lt;/h2&gt;\n&lt;p&gt;The simplest type of registration is when service is registered by its own type. For Type and Instance registration you could do so by simply registering the type or the instance:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;container.RegisterType&amp;lt;Foo&amp;gt;();\ncontainer.RegisterInstance(new Foo());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;A factory has to specify type it is registered under:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;container.RegisterFactory&amp;lt;Foo&amp;gt;((c, t, n) =&amp;gt; new Foo());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=&quot;mapping-contract-to-implementation&quot;&gt;Mapping Contract to Implementation&lt;/h2&gt;\n&lt;p&gt;When you map Registered type to implementation type you specify an service type first and implementation type second:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;container.RegisterType&amp;lt;IFoo, Foo&amp;gt;();\ncontainer.RegisterInstance&amp;lt;IFoo&amp;gt;(new Foo());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In case of factory registration the container does not care how it is implemented by the factory, all it cares is how it is registered:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;container.RegisterFactory&amp;lt;IFoo&amp;gt;((c, t, n) =&amp;gt; new Foo());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=&quot;building-and-mapping-to-implementation&quot;&gt;Building and Mapping to Implementation&lt;/h2&gt;\n&lt;p&gt;Mapping allows redirection to existing registrations and services as well as building new instances of implementation types.&lt;/p&gt;\n&lt;h3 id=&quot;mapping-to-existing-service&quot;&gt;Mapping to Existing Service&lt;/h3&gt;\n&lt;p&gt;The Unity container supports a scenario where a mapping does not crate type itself but rather references existing service registered with the container. Consider the following:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;public class Foo : IFoo1, IFoo2\n{\n    public Foo()\n    {\n    }\n\n    public Foo(object _)\n    {\n    }\n}\n\ncontainer.RegisterInstance&amp;lt;IFoo&amp;gt;(new Foo(), InstanceLifetime.Singleton);\n\ncontainer.RegisterType&amp;lt;IFoo1, Foo&amp;gt;();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The container has a registration for type &lt;code&gt;Foo&lt;/code&gt;. When interface &lt;code&gt;IFoo1&lt;/code&gt; is mapped to &lt;code&gt;Foo&lt;/code&gt; it instructs the container to resolve the default implementation for the type &lt;code&gt;Foo&lt;/code&gt;. Because the mapping does not provide any instructions how the type should be built, the default implementation, or existing registration should be used.&lt;/p&gt;\n&lt;p&gt;So, when the container will be resolving &lt;code&gt;IFoo1&lt;/code&gt; it will first check if &lt;code&gt;Foo&lt;/code&gt; is already registered and will used the registration to satisfy the request.&lt;/p&gt;\n&lt;p&gt;If a mapping references non existing service the container will try to build the service from the implementation type.&lt;/p&gt;\n&lt;h3 id=&quot;building-implementation-type&quot;&gt;Building Implementation Type&lt;/h3&gt;\n&lt;p&gt;If the implementation type points to no existing registration or if an instance has to be created using certain rules, the container will create a new, independent pipeline and execute. So if you register &lt;code&gt;IFoo2&lt;/code&gt; like this:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=&quot;lang-cs&quot;&gt;container.RegisterType&amp;lt;IFoo2, Foo&amp;gt;(Invoke.Constructor());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;the Unity container will not redirect to &lt;code&gt;Foo&lt;/code&gt; but will create a new instance of &lt;code&gt;Foo&lt;/code&gt; and call default constructor.&lt;/p&gt;\n\" />\r\n<meta name=\"content_git_url\" content=\"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Composition/Mapping/implementation.md\" />\r\n<meta name=\"depot_name\" content=\".\" />\r\n<meta name=\"document_id\" content=\"67e38e86-49da-e80c-aa14-d18939f99491\" />\r\n<meta name=\"document_version_independent_id\" content=\"6916f8de-fba9-4c35-b3b8-6cc40a8e8412\" />\r\n<meta name=\"gitcommit\" content=\"https://github.com/unitycontainer/documentation/blob/ba6c8d58ec404ad0451d4a77b857483b11fc2a78/tutorials/Composition/Mapping/implementation.md\" />\r\n<meta name=\"locale\" content=\"en-us\" />\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/unitycontainer/documentation/blob/develop/tutorials/Composition/Mapping/implementation.md\" />\r\n<meta name=\"original_content_git_url_template\" content=\"{repo}/blob/{branch}/tutorials/Composition/Mapping/implementation.md\" />\r\n<meta name=\"rawTitle\" content=\"&lt;h1 id=&quot;service-to-implementation-mapping&quot;&gt;Service to Implementation Mapping&lt;/h1&gt;\" />\r\n<meta name=\"search.ms_docsetname\" content=\"\" />\r\n<meta name=\"search.ms_product\" content=\"\" />\r\n<meta name=\"search.ms_sitename\" content=\"Docs\" />\r\n<meta name=\"site_name\" content=\"Docs\" />\r\n<meta name=\"title\" content=\"Service to Implementation Mapping\" />\r\n<meta name=\"uid\" content=\"Tutorial.Mapping.Implementation\" />\r\n<meta name=\"updated_at\" content=\"2019-04-30 01:18 AM\" />\r\n<meta name=\"wordCount\" content=\"351\" />\r\n<meta name=\"is_dynamic_rendering\" content=\"true\" />\r\n","theme_rel":"..\\..\\..\\..\\_themes"}